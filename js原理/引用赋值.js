function foo(x) {
  x.push( 4 );
  x; //[1,2,3,4]
  //然后
  x = [4,5,6];
  x.push( 7 );
  x; //[4,5,6,7]
}

var a = [1,2,3];
foo( a );
a; //[1,2,3,4]

//我们向函数传递a的时候，实际是将引用a的一个复本赋值给x，
//而a仍然指向[1,2,3]。在函数中我们可以通过引用x来更改数组
//的值(push(4)之后变成[1,2,3,4]).但x = [4,5,6]并不
//影响a的指向，所以a仍然指向[1,2,3,4]

//我们不能通过引用x来更改引用a的指向，只能更改a和x共同指向的值

function foo(x) {
  x.push ( 4 );

  x.length = 0;// 清空数组
  x.push( 4,5,6,7 );
  x;//[4,5,6,7]
}
var a = [1,2,3];
foo( a );

a;//[4,5,6,7]

//请记住：我们无法自行决定使用值复制还是引用复制，一切由值的类型来决定

//如果通过值复制的方式来传递复合值（如数组），就需要为其创建一个复本
//这样传递的就不再是原始值例如
foo( a. slice() );

//相反，如果要将标量基本类型值传递到函数内并进行更改，就需要将该值封装到一个复合
//值（对象、数组等）中，然后通过引用复制的方式传递
function foo(wrapper) {
  wrapper.a = 42;
}

var obj = {
  a: 2
};
foo( obj );
obj.a; //42

//与预期不同的是，虽然传递的是指向数字对象的引用复本，但我们并不能通过它来更改
//其中的基本类型值
functioin foo(x) {
  x = x + 1;
  x;//3
}
var a = 2;
var b = new Number( a );//Object(a)也一样

foo( b );
console.log( b );//2

//原因是标量基本类型值是不可更改的（字符串和布尔也是如此）。如果一个数字对象的
//标量类型值是2，那么该值就不能更改，除非创建一个包含新值的数字对象。
