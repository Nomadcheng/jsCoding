**let命令**

> 但是所声明的变量，只在let命令所在代码块内有效

```
var a = [];
for (var i = 0; i < 10; i++) {
  a[i] = function () {
    console.log(i);
  };
}
a[6](); // 10
```

上面代码中，变量i是let声明的，当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量， 所以最后输出的是6。你可能会问，如果每一轮循环的变量i都是重新声明的，那它怎么知道上一轮循环的值， 从而计算出本轮循环的值？这是因为 JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量i时， 就在上一轮循环的基础上进行计算。

> 不存在变量提升

var命令会发生"变量提升"现象，let命令改变了这种语法行为，它所声明的变量一定要在声明后使用，否则报错

```
//var
console.log(foo);//undefined
var foo = 2;

//let
console.log(bar);//ReferenceError
let bar = 2;
```

> 暂时性死区

只要块级作用域内存在let命令，它所声明的变量就"绑定"了这个区域，不再受外部的影响

```
var tmp = 123;
if(true) {
  tmp = 'abc'; //ReferenceError
  let tmp;
}
```

"暂时性死区"也意味着typeof不再是一个百分之百安全的操作。

```
typeof x; // ReferenceError
let x;
```

不允许重复声明 let不允许在相同作用域内，重复声明同一个变量，因此，不能在函数内部重新声明变量

> 为什么需要块级作用域

ES5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。

第一种场景，内层变量可能会覆盖外层变量。

```
var a = 1;

function f() {
  console.log(a);
  if(false) {
    var a = 0;
  }
}

f(); //undefined
```

第二种场景，用来计数的循环变量泄漏为全局变量

```
var s = 'hello';

for (var i = 0; i < s.length; i++) {
  console.log(s[i]);
}

console.log(i); // 5
```

上面代码中，变量i只是用来控制循环，但是循环结束后，它并没有消失，而是泄漏成了全局变量

> ES6的块级作用域

在ES5中，从来不会告诉你是否多次声明了同一个变量；遇到这种情况，它只会对后续的声明视而不见（不过，它后续声明中的变量初始化）。匿名函数可以用来模仿块级作用域来避免这个问题。

```
(function(){
  这里是块级作用域
  })()

var someFunction = function() {
  //这里是块级作用域
};
someFunction();
```

而let实际上为javascript新增了块级作用域

```
function f1() {
  let n = 5;
  if (true) {
    let n = 10;
  }
  console.log(n); // 5
}
```

上面的函数有两个代码块，都声明了变量n，运行后输出 5。这表示外层代码块不受内层代码块的影响。如果两次都使用var定义变量n，最后输出的值才是 10。

> 块级作用域与函数声明

考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。

```
// 函数声明语句
{
  let a = 'secret';
  function f() {
    return a;
  }
}

// 函数表达式
{
  let a = 'secret';
  let f = function () {
    return a;
  };
}
```

> do表达式

本质上，块级作用域是一个语句，将多个操作封装在一起，没有返回值。

```
{
  let t = f();
  t = t * t + 1;
}
```

上面代码中，块级作用域将两个语句封装在一起。但是，在块级作用域以外，没有办法得到t的值，因为块级作用域不返回值，除非t是全局变量。

现在有一个提案，使得块级作用域可以变为表达式，也就是说可以返回值，办法就是在块级作用域之前加上do，使它变为do表达式，然后就会返回内部最后执行的表达式的值。

```
let x = do {
  let t = f();
  t * t + 1;
};
```

上面代码中，变量x会得到整个块级作用域的返回值（t * t + 1）。

**const命令**

> const声明一个只读的常量，一旦声明，常量的值就不能改变

```
const PI = 3.1415;
PI // 3.1415

PI = 3;
// TypeError: Assignment to constant variable.
```

const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。

const的作用域与let命令相同：只在声明所在的块级作用域内有效。

```
if (true) {
  const MAX = 5;
}

MAX // Uncaught ReferenceError: MAX is not defined
```

const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。

const声明的常量，也与let一样不可重复声明。

> 本质

const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，const只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。

```
const foo = {};

// 为 foo 添加一个属性，可以成功
foo.prop = 123;
foo.prop // 123

// 将 foo 指向另一个对象，就会报错
foo = {}; // TypeError: "foo" is read-only
```

上面代码中，常量foo储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把foo指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。
